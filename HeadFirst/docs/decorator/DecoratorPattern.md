# 🖼️ 데코레이터 패턴

### ✨ 정의
- **<U>데코레이터 패턴</U>** 으로 객체에 추가 요소를 동적으로 처리할 수 있다.
- 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있다.
- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다.
- 한 객체를 여러 개의 데코레이터로 감쌀 수 있다.
- 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 
  - 원래 객체(싸여있는 객체)가 들어갈 자리에 데코레이터 객체를 넣어도 상관없다.
- 💥 데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있다. 💥
- 객체는 언제든지 감쌀 수 있으므로 실행 중에 필요한 데코레이터를 마음대로 적용할 수 있다.

### ✨ OCP(Open-Closed Principle) 개방 폐쇄 원칙
- 확장에는 열려있고, 변경에는 닫혀있다.
- 코드에서 확장해야 할 부분을 선택할 때는 세심한 주의가 필요하다.
- 무조건적인 도입과 고민에 대한 주의가 필요하다.

### ✨ 핵심 정리
- 디자인의 유연성 면에서 상속으로 확장하는 일은 별로 좋은 선택이 아님.
- 기존 코드 수정 없이 행동을 확장해야 하는 상황도 있음.
- 구성과 위임으로 실행 중에 새로운 행동을 추가할 수 있음.
- 상속 대신 데코레이터 패턴으로 행동을 확장할 수 있음.
- 데코레이터 패턴은 구상 구성요소를 감싸 주는 데코레이터를 사용함.
- 데코레이터 클래스의 형식은 그 클래스가 감싸는 클래스 형식을 반영함.
  - (상속이나 인터페이스 구현으로 자신이 감쌀 클래스와 같은 형식을 가짐.)
- 구성 요소를 감싸는 데코레이터의 개수에는 제한이 없음.
- 구성 요소의 클라이언트는 데코레이터의 존재를 알 수 없음.
- 클라이언트가 구성 요소의 구체적인 형식에 의존하는 경우는 예외임.
- 👺 데코레이터 패턴을 사용하면 자잘한 객체가 매우 많이 추가될 수 있고, 데코레이터를 너무 많이 사용하면 코드가 필요 이상으로 복잡해진다. 👺 
